<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <!--<script type="text/javascript" src="http://livejs.com/live.js"></script> -->
    <script type="text/javascript" src="./resources/noisejs/perlin.js"></script>
  </head>
  <body>
    <div id="container"></div>
    <script type="module" src="./collision.js"></script>
    <script type="module">
      import {attack} from './collision.js';
      import * as THREE from './resources/three/build/three.module.js';
      import {GLTFLoader} from './resources/three/examples/jsm/loaders/GLTFLoader.js';
      import {OrbitControls} from './resources/three/examples/jsm/controls/OrbitControls.js';
      import {SkeletonUtils} from './resources/three/examples/jsm/utils/SkeletonUtils.js';

      /**
       * Parameters
       */
      // Camera
      const aspect = window.innerWidth / window.innerHeight;
      const near   = 5;
      const far    = 1000;
      const d      = 11;
      // Scene
      const backgroundColor = 0x281E5D; // indigo
      const colorPotion     = 0xB8FF70;
      const colorFlame      = 0xFC8A17;
      const flameDistance   = 14;
      

      
      /**
       * Main function
       */
      function main() {
	  /**
	   * Define scope-related objects
	   */
	  // Base objects
	  const container = document.getElementById('container');
	  const renderer  = new THREE.WebGLRenderer();
	  const camera    = new THREE.OrthographicCamera(-d * aspect, d*aspect, d, -d, near, far);
	  const scene     = new THREE.Scene();
	  const clock     = new THREE.Clock();

	  const bboxes     = [];
	  const collisions = [];

	  // Initialize noise generator
	  noise.seed(0);	  
	  
	  
	  // Animated objects section
	  // Define models
	  const MODELS = [
	      {   // Skeleton model
		  filename: 'simguy/simguy'
	      },
	      {   // Map model
		  filename: 'map/map',
		  unique  : true
	      }
	  ];
	  // Define units
	  const UNITS = [
	      {
		  modelName:   'map/map',
	      },
	      {
		  modelName:   'simguy/simguy',
		  meshName:    'baseframe',
		  position:    {x: 5, y: 0, z: 5},
		  rotation:    {x: 0, y: 1, z: 0},
		  scale:       0.3,
		  planner:     'randomwalk'
	      }
	  ];

	  /** 
	   * Animation Handling
	   */
	  /**
	   * @Class
	   * Base AnimationHandler class
	   */
	  class AnimationHandler {
	      constructor(object) {
		  this.object = object;
		  this.time   = 0;
	      }
	  }
	  /**
	   * @Class
	   * TorchAnimation class. Handle animations for torches
	   */
	  class TorchAnimation extends AnimationHandler {
	      constructor(object, timeScale, ampMult) {
		  super(object);
		  this.timeScale = timeScale;
		  this.ampMult = ampMult;
		  this.basePos  = new THREE.Vector3().copy(object.position);
	      }	      
	      update(deltaTime) {
		  this.time += deltaTime;
		  const increment = Math.sin(this.time * this.timeScale) * this.ampMult;
		  this.object.position.y = this.basePos.y + increment;
		  this.object.rotation.y = (this.time * this.timeScale) % (2 * Math.PI);
	      }
	  }
	  /**
	   * @Class
	   * SkeletonAnimation class. Handle animations for skeletons.
	   */
	  class SkeletonAnimation extends AnimationHandler {
	      constructor (object) {
		  super(object);
	      }
	  }
	  
	  const animations = [];

	  /** 
	   * Trajectory Planner
	   */
	  const planners = [];
	  

	  initRenderer();
	  initCamera();
	  initScene();

	  // Instantiate skeletons
	  loadModels();
	  initMapLights(MODELS[1].scene);
	  render();

	  // Temp controls [DEBUG]
	  const controls  = new OrbitControls(camera, renderer.domElement);
	  controls.update();
	  
	  /**
	   * @Class
	   * Base Planner Class
	   */
	  class Planner {
	      constructor(object) {
		  this.object = object;
	      }
	  }

	  /**
	   * @Class
	   * RandomWalk Planner
	   */
	  class RandomWalker extends Planner {
	      constructor(object, bbox, step) {
		  super(object);
		  this.bbox = bbox;
		  this.step = step;
		  this.safePos = new THREE.Vector3().copy(object.position);
	      }
	      update(time, collisionTarget) {
		  this.bbox.setFromObject(this.object);
		  attack();
		  // Check if collision happened
		  if (collisionTarget) {
		      
		  } else {  
		      const rnStep = noise.perlin3(this.object.position.x,
						   this.object.position.z,
						   time);
		      this.object.rotateOnAxis(new THREE.Vector3(0, 1, 0), rnStep * this.step);
		      this.object.translateOnAxis(new THREE.Vector3(1, 0, 0), Math.random() * this.step);
		  }
	      }
	  }
	   
	  /**
	   * Rendering function
	   */
	  function render() {
	      // get the time elapsed since the last frame
	      var updateDelta = clock.getDelta();
	      
	      // Update animations
	      for (let i = 0; i < animations.length; ++i) {
		  animations[i].update(updateDelta);
	      }
	      
	      // Call TrajectoryPlanners
	      for (let i = 0; i < planners.length; ++i) {
		  // Check for collisions
		  const targetBB = checkCollision(planners[i].bbox);		  
		  planners[i].update(clock.elapsedTime, targetBB);
	      }
	      
	      renderer.render(scene, camera);
	      requestAnimationFrame(render);
	  }

	  



	  // ------------------Function Sector-----------------------------------
	  

	  /**
	   * Initalizing functions
	   */
	  function initRenderer() {
	      renderer.shadowMap.enabled = true;
	      renderer.setPixelRatio(window.devicePixelRatio);
	      renderer.setSize( window.innerWidth, window.innerHeight);
	      renderer.outputEncoding = THREE.sRGBEncoding;
	      container.appendChild(renderer.domElement);
	  }
	  function initCamera() {
	      camera.position.set(20, 20, -20);
	  }
	  function initScene() {
	      scene.background = new THREE.Color(backgroundColor);
	  }

	  function initMapLights(mapScene) {
	      add_pointLight([0, 2, 0], colorPotion, 1, 8);
	      const lightPositions = [
		  [-6.5, 3.4, -5.5],
		  [6.5, 3.4, 7],
		  [-3, 3.4, 7],
		  [10, 3.4, -10]
	      ];
	      for (let i = 0; i < lightPositions.length; ++i) {
		  let torchLight;
		  if (i == lightPositions.length - 1) {
		      // Last light, decrease brightness
		      torchLight = add_pointLight(lightPositions[i], colorFlame, 0.4,
							flameDistance);
		  } else {
		      torchLight = add_pointLight(lightPositions[i], colorFlame, 1.5,
							flameDistance);
		  }
		  // Install the light into torch animationHandler
		  animations.push(new TorchAnimation(torchLight, 5, 0.05));
	      }
	      
	      function add_pointLight(position, color, intensity, distance) {
		  const light = new THREE.PointLight(color, intensity);
		  light.castShadow = true;
		  light.distance = distance;
		  // Helper
		  //const helper = new THREE.PointLightHelper(light);
		  //scene.add(helper);
		  //<------
		  light.position.set(position[0], position[1], position[2]);
		  scene.add(light);
		  return light;
	      }	      
	  }
	  /**
	   * Load a 3D model from a GLTF file.
	   */
	  function loadGltfModel(model, onLoaded) {
	      const loader = new GLTFLoader();
	      const modelName = './resources/models/' + model.filename + '.gltf';
	      loader.load( modelName, (gltf) => {
		  const root = gltf.scene;
		  model.scene = root;
		  // Enable shadows
		  if (model.filename == 'map/map') {
		      gltf.scene.traverse( (object) => {
			  if (object.isMesh) {
			      function shouldCast(obj) {
				  const matName = obj.material.name;
				  const blackList = ['torch', 'torch_stick', 'torch_ring'];
				  if (blackList.includes(matName)) {
				      return false;
				  }
				  return true;
			      }
			      if (shouldCast(object)) {
				  initMapObjectBBox(object);
				  object.castShadow = true;
				  object.receiveShadow = true;
			      }
			      if (object.material.name == 'torch') {
				  animations.push(new TorchAnimation(object, 8, 0.05));
			      }
			  }});
		  } else {
		      gltf.scene.traverse( (object) => {
			  object.castShadow = true;
		      });
		  }
		  onLoaded();
	      });
	  }
      
	  /**
	   * Returns the index of the reference model, given its name
	   */
	  function getModelByName(name) {
	      for (let i = 0; i < MODELS.length; ++i) {
		  if (name == MODELS[i].filename) {
		      return MODELS[i];
		  }		  
	      }
	      return null;
	  }

	  /**
	   * Instantiate the predefined units
	   */
	  function istantiateUnits(units) {
	      let successNumber = 0;
	      for (let i = 0; i < units.length; ++i) {
		  const u = units[i];
		  const model = getModelByName(u.modelName);
		  if (model) {
		      // model exists. copy the instance
		      let clonedScene = null;
		      if (model.unique) {
			  // if unique flag is defined, do not clone the object
			  scene.add(model.scene);
			  u.scene = model.scene;
		      } else {			  
			  clonedScene = SkeletonUtils.clone(model.scene);
		      }
		      if (clonedScene) {
			  // Scene cloned properly
			  const clonedMesh = clonedScene.getObjectByName(u.meshName);
			  if (clonedMesh) {
			      // Success
			      // TODO
			      successNumber++;
			  }
			  scene.add(clonedScene);
			  u.scene = clonedScene;
			  // Apply given transforms
			  if (u.position) {
			      clonedScene.position.set(u.position.x, u.position.y, u.position.z);
			  }
			  if (u.scale) {
			      clonedScene.scale.set(u.scale, u.scale, u.scale);
			  }
			  if (u.rotation) {
			      clonedScene.rotation.x = u.rotation.x;
			      clonedScene.rotation.y = u.rotation.y;
			      clonedScene.rotation.z = u.rotation.z;
			  }
			  // Create bounding box for the unit
			  const bbox = new THREE.Box3().setFromObject(clonedScene);
			  clonedScene.bbox = bbox;
			  bboxes.push(bbox);
			  // Add helper
			  scene.add(new THREE.Box3Helper(bbox, 0xffff00));
			  
			  // Attach Planner
			  if (u.planner) {
			      if (u.planner == 'randomwalk')
				  planners.push(new RandomWalker(clonedScene, bbox, 0.1));
			      
			  }
			  console.log(clonedScene);
			  
		      }
		  } else {
		      console.error("Can not find model", u.modelName);
		  }
	      }
	      console.log('Succesfully loaded', successNumber, ' models.');
	  }

	  /**
	   * Load models routine
	   */
	  function loadModels() {
	      let numLoadedModels = 0;
	      for (let i = 0; i < MODELS.length; ++i) {
		  const m = MODELS[i];
		  loadGltfModel(m, () => {
		      ++numLoadedModels;
		      if (numLoadedModels == MODELS.length) {
			  console.log('All models loaded. Instancing...');
			  istantiateUnits(UNITS);
		      }
		  });
	      }
	  }
	  

	  /**
	   * Compute Bounding Boxes for the map
	   */
	  function initMapObjectBBox(object) {
	      const blackList = [
		  'floor',
		  'Plane005',
		  'Plane',
		  'firepit',
		  'potatoes',
		  'hole'		  
	      ];
	      if (blackList.includes(object.name)) {
		  return;
	      }
	      const bbox = new THREE.Box3().setFromObject(object);
	      bboxes.push(bbox);
	      scene.add(new THREE.Box3Helper(bbox));
	  }

	  /**
	   * Check for collisions
	   */
	  function checkCollision(bbox) {
	      for (let i = 0; i < bboxes.length; ++i) {
		  if (bboxes[i] == bbox) continue;
		  if (bbox.intersectsBox(bboxes[i])) return bboxes[i];
	      }
	      return null;
	  }

	  /**
	   * Compute collision offset
	   */
	  function computeCollisionOffset(objectBB, collisionBB) {
	      const cMax = collisionBB.max;
	      const cMin = collisionBB.min;
	      const oMax = objectBB.max;
	      const oMin = objectBB.min;
	      const cDist = cMin.clone().sub(cMax);
	      const offset = new THREE.Vector3(0, 0, 0);
	      if (cMax.x == oMax.x) offset.x += cDist.x;
	      if (cMax.z == oMax.z) offset.z += cDist.z;
	      if (cMin.x == oMin.x) offset.x -= cDist.x;
	      if (cMin.z == oMin.z) offset.z -= cDist.z;
	      return offset;
	  }
	  
      } // function main()
      main();
    </script>
  </body>
</html>
