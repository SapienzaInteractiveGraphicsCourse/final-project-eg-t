<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <!--<script type="text/javascript" src="http://livejs.com/live.js"></script> -->
    <script type="text/javascript" src="./resources/noisejs/perlin.js"></script>
  </head>
  <body>
    <div id="container"></div>
    <script type="module">
      import * as THREE from './resources/three/build/three.module.js';
      import {GLTFLoader} from './resources/three/examples/jsm/loaders/GLTFLoader.js';
      import {OrbitControls} from './resources/three/examples/jsm/controls/OrbitControls.js';
      import {SkeletonUtils} from './resources/three/examples/jsm/utils/SkeletonUtils.js';

      /**
       * Parameters
       */
      // Camera
      const aspect = window.innerWidth / window.innerHeight;
      const near   = 5;
      const far    = 1000;
      const d      = 11;
      // Scene
      const backgroundColor = 0x281E5D; // indigo
      const colorPotion     = 0xB8FF70;
      const colorFlame      = 0xFC8A17;
      const flameDistance   = 14;
      

      
      /**
       * Main function
       */
      function main() {
	  /**
	   * Define scope-related objects
	   */
	  // Base objects
	  const container = document.getElementById('container');
	  const renderer  = new THREE.WebGLRenderer();
	  const camera    = new THREE.OrthographicCamera(-d * aspect, d*aspect, d, -d, near, far);
	  const scene     = new THREE.Scene();
	  const clock     = new THREE.Clock();

	  // bboxes
	  const bboxes       = [];

	  // Initialize noise generator
	  noise.seed(0);
	  
	  
	  // Animated objects section
	  // Define models
	  const MODELS = [
	      {   // Skeleton model
		  filename: 'skeleton/skeletorn_rig'
	      },
	      {   // Map model
		  filename: 'map/map',
		  unique  : true
	      }
	  ];
	  // Define units
	  const UNITS = [
	      {
		  modelName:   'map/map',
	      },
	      {
		  modelName:   'skeleton/skeletorn_rig',
		  meshName:    'cube',
		  //position:    {x: 0, y: 0, z: 0},
		  //rotation:    {x: 0, y: 0, z: 0},
		  scale:       0.3
	      },
	      {
		  modelName:  'skeleton/skeletorn_rig',
		  meshName:   'cube',
		  position:   {x: 5, y: 0, z: 0},
		  rotation:   {x: 0, y: Math.PI/2, z: 0},
		  scale:      0.3
	      },
	      {
		  modelName:  'skeleton/skeletorn_rig',
		  meshName:   'cube',
		  position:   {x: -2, y: 0, z: -6},
		  rotation:   {x: 0, y: -Math.PI/2, z: 0},
		  scale:      0.3
	      },
	      {
		  modelName:  'skeleton/skeletorn_rig',
		  meshName:   'cube',
		  position:   {x: -2, y: 0, z: 6},
		  rotation:   {x: 0, y: Math.PI/2, z: 0},
		  scale:      0.3
	      },
	  ];

	  /** 
	   * Animation Handling
	   */
	  const animationHandlers = [
	      {// TorchLights handler
		  name: 'torchLights',
		  meshes: [],
		  base:   [],
		  time: 0,
		  timeScale: 5,
		  install: function(mesh) {
		      this.meshes.push(mesh);
		      this.base.push(mesh.position);
		  },
		  update: function(deltaTime) {
		      this.time += deltaTime;
		      const increment = Math.sin(this.time * this.timeScale) / 200;
		      for( let i = 0; i < this.meshes.length; ++i) {
			  this.meshes[i].position.set(this.base[i].x,
						      this.base[i].y + increment,
						      this.base[i].z);
		      }
		  }
	      },
	      {// Torch handler
		  name: 'torch',
		  meshes: [],
		  base:   [],
		  time:   0,
		  timeScale: 5,
		  install: function(mesh) {
		      this.meshes.push(mesh);
		      this.base.push(mesh.position);
		  },
		  update: function(deltaTime) {
		      this.time += deltaTime;
		      const increment = Math.sin(this.time * this.timeScale) / 200;
		      for( let i = 0; i < this.meshes.length; ++i) {
			  this.meshes[i].position.y = this.base[i].y + increment;
			  this.meshes[i].rotation.y = (this.time * this.timeScale) % (2 * Math.PI);
		      }
		  }
	      }
	      // TODO
	  ];

	  /** 
	   * Trajectory Planner
	   */
	  const trajectoryPlanner = [];
	  

	  initRenderer();
	  initCamera();
	  initScene();

	  // Instantiate skeletons
	  loadModels();
	  initMapLights(MODELS[1].scene);
	  render();

	  	  // Temp controls [DEBUG]
	  const controls  = new OrbitControls(camera, renderer.domElement);
	  controls.update();

	  // TEST PLANNER
	  const foolPlanner = {
	      update: function(object, time) {
		  const step = 0.005;
		  object.position.set(object.position.x * (1 - step),
				      object.position.y * (1 - step),
				      object.position.z * (1 - step));				      
	      }
	  };
	  const randomWalkPlanner = {
	      update: function(object, time) {
		  // Update BBOX
		  object.bbox.setFromObject(object).translate(new THREE.Vector3(0, 3.8, 0));
		  
		  const step = 0.1;
		  const pos = object.position;
		  const rotation_step = noise.perlin3(pos.x, pos.y, time);
		  object.rotation.set(object.rotation.x,
				      object.rotation.y + rotation_step * 0.1,
				      object.rotation.z);
		  let targetBBox = checkCollision(object.bbox);
		  if(targetBBox) {
		      // Handle collision
		      
		  }
		  object.translateOnAxis(new THREE.Vector3(1, 0, 0), Math.random() * step);
	      }
	  };
	  



	  /**
	   * Rendering function
	   */
	  function render() {
	      // get the time elapsed since the last frame
	      var updateDelta = clock.getDelta();

	      // Update Bounding Boxes
	      

	      
	      // Update animation frames TODO
	      for (let i = 0; i < animationHandlers.length; ++i) {
	          animationHandlers[i].update(updateDelta);
	      }
	      // Call TrajectoryPlanners
	      for (let i = 0; i < trajectoryPlanner.length; ++i) {
		  let object = trajectoryPlanner[i].object;
		  trajectoryPlanner[i].planner.update(object, clock.elapsedTime);
	      }
	      
	      renderer.render(scene, camera);
	      requestAnimationFrame(render);
	  }

	  



	  // ------------------Function Sector-----------------------------------
	  

	  /**
	   * Initalizing functions
	   */
	  function initRenderer() {
	      renderer.shadowMap.enabled = true;
	      renderer.setPixelRatio(window.devicePixelRatio);
	      renderer.setSize( window.innerWidth, window.innerHeight);
	      renderer.outputEncoding = THREE.sRGBEncoding;
	      container.appendChild(renderer.domElement);
	  }
	  function initCamera() {
	      camera.position.set(20, 20, -20);
	  }
	  function initScene() {
	      scene.background = new THREE.Color(backgroundColor);
	  }

	  function initMapLights(mapScene) {
	      add_pointLight([0, 2, 0], colorPotion, 1, 8);
	      const lightPositions = [
		  [-6.5, 3.4, -5.5],
		  [6.5, 3.4, 7],
		  [-3, 3.4, 7],
		  [10, 3.4, -10]
	      ];
	      for (let i = 0; i < lightPositions.length; ++i) {
		  let torchLight;
		  if (i == lightPositions.length - 1) {
		      // Last light, decrease brightness
		      torchLight = add_pointLight(lightPositions[i], colorFlame, 0.4,
							flameDistance);
		  } else {
		      torchLight = add_pointLight(lightPositions[i], colorFlame, 1.5,
							flameDistance);
		  }
		  // Install the light into torch animationHandler
		  animationHandlers[0].install(torchLight);		  
	      }
	      
	      function add_pointLight(position, color, intensity, distance) {
		  const light = new THREE.PointLight(color, intensity);
		  light.castShadow = true;
		  light.distance = distance;
		  // Helper
		  //const helper = new THREE.PointLightHelper(light);
		  //scene.add(helper);
		  //<------
		  light.position.set(position[0], position[1], position[2]);
		  scene.add(light);
		  return light;
	      }	      
	  }
	  
	  /**
	   * Load a 3D model from a GLTF file.
	   */
	  function loadGltfModel(model, onLoaded) {
	      const loader = new GLTFLoader();
	      const modelName = './resources/models/' + model.filename + '.gltf';
	      loader.load( modelName, (gltf) => {
		  const root = gltf.scene;
		  model.scene = root;
		  // Enable shadows
		  if (model.filename == 'map/map') {
		      console.debug(gltf.scene);
		      gltf.scene.traverse( (object) => {
			  if (object.isMesh) {
			      function shouldCast(obj) {
				  const matName = obj.material.name;
				  const blackList = ['torch', 'torch_stick', 'torch_ring'];
				  if (blackList.includes(matName)) {
				      return false;
				  }
				  return true;
			      }
			      if (shouldCast(object)) {
				  initMapObjectBBox(object);
				  object.castShadow = true;
				  object.receiveShadow = true;
			      }
			      if (object.material.name == 'torch') {
				  animationHandlers[1].install(object);
			      }
			  }});
		  } else {
		      gltf.scene.traverse( (object) => {
			  object.castShadow = true;
		      });
		  }
		  onLoaded();
	      });
	  }
      
	  /**
	   * Returns the index of the reference model, given its name
	   */
	  function getModelByName(name) {
	      for (let i = 0; i < MODELS.length; ++i) {
		  if (name == MODELS[i].filename) {
		      return MODELS[i];
		  }		  
	      }
	      return null;
	  }

	  /**
	   * Instantiate the predefined units
	   */
	  function istantiateUnits(units) {
	      let successNumber = 0;
	      for (let i = 0; i < units.length; ++i) {
		  const u = units[i];
		  const model = getModelByName(u.modelName);
		  if (model) {
		      // model exists. copy the instance
		      let clonedScene = null;
		      if (model.unique) {
			  // if unique flag is defined, do not clone the object
			  scene.add(model.scene);
			  u.scene = model.scene;
		      } else {			  
			  clonedScene = SkeletonUtils.clone(model.scene);
		      }
		      if (clonedScene) {
			  // Scene cloned properly
			  const clonedMesh = clonedScene.getObjectByName(u.meshName);
			  if (clonedMesh) {
			      // Success
			      // TODO
			      successNumber++;
			  }
			  scene.add(clonedScene);
			  u.scene = clonedScene;
			  // Apply given transforms
			  if (u.position) {
			      clonedScene.position.set(u.position.x, u.position.y, u.position.z);
			  }
			  if (u.scale) {
			      clonedScene.scale.set(u.scale, u.scale, u.scale);
			  }
			  if (u.rotation) {
			      clonedScene.rotation.x = u.rotation.x;
			      clonedScene.rotation.y = u.rotation.y;
			      clonedScene.rotation.z = u.rotation.z;
			  }
			  // Create bounding box for the unit
			  const bbox = new THREE.Box3().setFromObject(clonedScene).translate(new THREE.Vector3(0, 3.5, 0));
			  clonedScene.bbox = bbox;
			  bboxes.push(bbox);
			  // Add helper
			  scene.add(new THREE.Box3Helper(bbox, 0xffff00));
			  
			  //attachPlanner(clonedScene, randomWalkPlanner);
			  console.debug(clonedScene);
		      }
		  } else {
		      console.error("Can not find model", u.modelName);
		  }
	      }
	      console.log('Succesfully loaded', successNumber, ' models.');
	  }

	  /**
	   * Load models routine
	   */
	  function loadModels() {
	      let numLoadedModels = 0;
	      for (let i = 0; i < MODELS.length; ++i) {
		  const m = MODELS[i];
		  loadGltfModel(m, () => {
		      ++numLoadedModels;
		      if (numLoadedModels == MODELS.length) {
			  console.log('All models loaded. Instancing...');
			  istantiateUnits(UNITS);
		      }
		  });
	      }
	  }

	  /**
	   * Trajectory Planner Functions
	   */
	  function attachPlanner(object, planner) {
	      trajectoryPlanner.push({object, planner});
	  }

	  /**
	   * Compute Bounding Boxes for the map
	   */
	  function initMapObjectBBox(object) {
	      const blackList = [
		  'floor',
		  'Plane005',
		  'Plane'
	      ];
	      if (blackList.includes(object.name)) {
		  return;
	      }
	      const bbox = new THREE.Box3().setFromObject(object);
	      bboxes.push(bbox);
	      scene.add(new THREE.Box3Helper(bbox));
	  }

	  /**
	   * Check for collisions
	   */
	  function checkCollision(bbox) {
	      for (let i = 0; i < bboxes.length; ++i) {
		  if (bboxes[i] == bbox) continue;
		  if (bbox.intersectsBox(bboxes[i])) return bboxes[i];
	      }
	      return null;
	  }
      } // function main()
      main();
    </script>
  </body>
</html>
